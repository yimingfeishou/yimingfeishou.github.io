<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <title>CPU-TEST</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-container {
            border: 1px solid #ccc;
            padding: 20px;
            margin: 20px 0;
        }
        .progress-bar {
            height: 20px;
            background-color: #eee;
            margin: 10px 0;
        }
        .progress {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s;
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f8f8;
        }
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <h1>CPU性能测试工具</h1>
    
    <div class="test-container">
        <h2>CPU性能测试</h2>
        <div class="progress-bar">
            <div class="progress" id="cpu-progress"></div>
        </div>
        <button onclick="startCPUTest()">开始CPU测试</button>
        <button onclick="stopTests()" style="background-color: #f44336;">停止测试</button>
        <h3>测试期间您的CPU占用率会上升，这并非是挖矿脚本，而是CPU测试时的正常现象</h3>
        <h3>测试会持续大约40秒，请耐心等待</h3>
    </div>

    <div class="result" id="result">
        测试结果将显示在这里...
    </div>

    <p>建议使用Google Chrome；Microsoft Edge；Firefox等现代浏览器，使用Internet Explorer 11及以下版本或使用 Microsoft Edge 中的“在 Internet Explorer 模式下重新加载”会导致无法开始测试</p>
    <a href="https://wwf.lanzoul.com/iAL7Z38xr6dg" target="_blank">下载Windows 10/Windows 11 64位版本，密码：Arce</a>
    <p>注意：桌面版本的CPU测试会在下载时被Microsoft Defender SmartScreen拦截，此应用在GitHub上为开源状态，可随时查看</p>
    <a href="https://github.com/yimingfeishou/CPU-TEST" target="_blank">CPU-TEST GitHub仓库</a>

<script>
    let workers = [];
    let isTesting = false;
    let startTime;
    let testInterval;

    // 测试配置
    const TEST_CONFIG = {
        duration: 10000, // 每个测试持续时间10秒
        matrixSize: 512, // 矩阵大小
        primeLimit: 1000000, // 素数计算上限
        memorySize: 1000000, // 内存测试大小
        weights: {
            singleCore: 0.3,
            multiCore: 0.4,
            memory: 0.2,
            crypto: 0.1
        }
    };

    // CPU测试逻辑
    async function startCPUTest() {
        if(isTesting) return;
        isTesting = true;
        startTime = Date.now();
        document.getElementById('result').innerHTML = "测试进行中...";
        
        const progress = document.getElementById('cpu-progress');
        const results = {};
        
        // 更新进度条的函数
        function updateProgress(percent) {
            progress.style.width = percent + '%';
        }
        
        try {
            // 1. 单核性能测试 (类CPU-Z)
            updateProgress(25);
            results.singleCore = await runSingleCoreTest();
            
            // 2. 多核性能测试 (类Cinebench R23)
            updateProgress(50);
            results.multiCore = await runMultiCoreTest();
            
            // 3. 内存性能测试
            updateProgress(75);
            results.memory = await runMemoryTest();
            
            // 4. 加密性能测试 (AES类似加密算法)
            updateProgress(90);
            results.crypto = await runCryptoTest();
            
            // 计算综合评分
            updateProgress(100);
            const totalScore = calculateTotalScore(results);
            
            // 显示结果
            showResult(createResultHTML(results, totalScore));
            
        } catch (e) {
            console.error("测试出错:", e);
            showResult("测试过程中发生错误: " + e.message);
        }
        
        isTesting = false;
    }

    // 单核性能测试
    function runSingleCoreTest() {
        return new Promise(resolve => {
            // 使用多种计算任务模拟真实负载
            const tasks = [
                () => calculatePrimes(TEST_CONFIG.primeLimit), // 素数计算
                () => matrixMultiplication(TEST_CONFIG.matrixSize), // 矩阵乘法
                () => runPhysicsSimulation(1000) // 物理模拟
            ];
            
            let totalOperations = 0;
            const start = performance.now();
            const endTime = start + TEST_CONFIG.duration;
            
            // 运行测试直到达到指定时间
            function runTasks() {
                if (performance.now() > endTime || !isTesting) {
                    const duration = (performance.now() - start) / 1000;
                    resolve(totalOperations / duration);
                    return;
                }
                
                // 执行所有任务
                for (const task of tasks) {
                    task();
                    totalOperations++;
                }
                
                // 使用setTimeout让出主线程，避免界面完全冻结
                setTimeout(runTasks, 0);
            }
            
            runTasks();
        });
    }

    // 多核性能测试
    function runMultiCoreTest() {
        return new Promise(resolve => {
            const workerCount = navigator.hardwareConcurrency || 4;
            let completed = 0;
            let totalOps = 0;
            
            workers = [];
            
            for (let i = 0; i < workerCount; i++) {
                const worker = new Worker(URL.createObjectURL(
                    new Blob([`
                        let operations = 0;
                        const start = Date.now();
                        const endTime = start + ${TEST_CONFIG.duration};
                        
                        function runTest() {
                            if (Date.now() > endTime) {
                                postMessage(operations);
                                return;
                            }
                            
                            // 执行计算密集型任务
                            for (let i = 0; i < 1000; i++) {
                                // 模拟复杂计算
                                const matrixSize = 100;
                                let a = new Array(matrixSize * matrixSize);
                                let b = new Array(matrixSize * matrixSize);
                                let result = new Array(matrixSize * matrixSize);
                                
                                for (let j = 0; j < a.length; j++) {
                                    a[j] = Math.random();
                                    b[j] = Math.random();
                                }
                                
                                // 简化的矩阵乘法
                                for (let row = 0; row < matrixSize; row++) {
                                    for (let col = 0; col < matrixSize; col++) {
                                        let sum = 0;
                                        for (let k = 0; k < matrixSize; k++) {
                                            sum += a[row * matrixSize + k] * b[k * matrixSize + col];
                                        }
                                        result[row * matrixSize + col] = sum;
                                    }
                                }
                                
                                operations++;
                            }
                            
                            setTimeout(runTest, 0);
                        }
                        
                        runTest();
                    `])
                ));
                
                workers.push(worker);
                
                worker.onmessage = (e) => {
                    totalOps += e.data;
                    completed++;
                    if (completed === workerCount) {
                        resolve(totalOps / (TEST_CONFIG.duration / 1000));
                    }
                };
            }
        });
    }

    // 内存性能测试
    function runMemoryTest() {
        return new Promise(resolve => {
            const start = performance.now();
            const endTime = start + TEST_CONFIG.duration;
            let operations = 0;
            
            function testMemory() {
                if (performance.now() > endTime || !isTesting) {
                    const duration = (performance.now() - start) / 1000;
                    resolve(operations / duration);
                    return;
                }
                
                // 创建大型数组测试内存访问速度
                const array = new Float64Array(TEST_CONFIG.memorySize);
                
                // 顺序写入
                for (let i = 0; i < array.length; i++) {
                    array[i] = Math.random();
                }
                
                // 顺序读取
                let sum = 0;
                for (let i = 0; i < array.length; i++) {
                    sum += array[i];
                }
                
                // 随机访问
                for (let i = 0; i < array.length / 10; i++) {
                    const index = Math.floor(Math.random() * array.length);
                    array[index] = array[index] * 1.1;
                }
                
                operations++;
                
                // 使用setTimeout让出主线程
                setTimeout(testMemory, 0);
            }
            
            testMemory();
        });
    }

    // 加密算法性能测试
    function runCryptoTest() {
        return new Promise(resolve => {
            const start = performance.now();
            const endTime = start + TEST_CONFIG.duration;
            let operations = 0;
            
            function testCrypto() {
                if (performance.now() > endTime || !isTesting) {
                    const duration = (performance.now() - start) / 1000;
                    resolve(operations / duration);
                    return;
                }
                
                // 模拟加密操作 (简化版AES类算法)
                const data = new Array(256);
                for (let i = 0; i < data.length; i++) {
                    data[i] = Math.floor(Math.random() * 256);
                }
                
                // 简化的加密过程
                for (let round = 0; round < 10; round++) {
                    // 模拟字节替换
                    for (let i = 0; i < data.length; i++) {
                        data[i] = (data[i] * 13 + 17) % 256;
                    }
                    
                    // 模拟行移位
                    for (let i = 0; i < 16; i++) {
                        const row = i * 16;
                        const shift = i % 4;
                        if (shift > 0) {
                            const temp = data.slice(row, row + shift);
                            for (let j = 0; j < 16 - shift; j++) {
                                data[row + j] = data[row + j + shift];
                            }
                            for (let j = 0; j < shift; j++) {
                                data[row + 16 - shift + j] = temp[j];
                            }
                        }
                    }
                    
                    // 模拟列混合
                    for (let col = 0; col < 16; col++) {
                        const values = [
                            data[col], data[col + 16], data[col + 32], data[col + 48]
                        ];
                        
                        data[col] = (values[0] * 2 + values[1] * 3 + values[2] + values[3]) % 256;
                        data[col + 16] = (values[0] + values[1] * 2 + values[2] * 3 + values[3]) % 256;
                        data[col + 32] = (values[0] + values[1] + values[2] * 2 + values[3] * 3) % 256;
                        data[col + 48] = (values[0] * 3 + values[1] + values[2] + values[3] * 2) % 256;
                    }
                }
                
                operations++;
                
                // 使用setTimeout让出主线程
                setTimeout(testCrypto, 0);
            }
            
            testCrypto();
        });
    }

    // 辅助函数 - 计算素数
    function calculatePrimes(limit) {
        const primes = [];
        const isPrime = new Array(limit + 1).fill(true);
        
        isPrime[0] = isPrime[1] = false;
        
        for (let i = 2; i <= limit; i++) {
            if (isPrime[i]) {
                primes.push(i);
                for (let j = i * i; j <= limit; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        
        return primes;
    }

    // 辅助函数 - 矩阵乘法
    function matrixMultiplication(size) {
        // 创建矩阵
        const a = new Array(size * size);
        const b = new Array(size * size);
        const result = new Array(size * size);
        
        // 初始化矩阵
        for (let i = 0; i < size * size; i++) {
            a[i] = Math.random();
            b[i] = Math.random();
            result[i] = 0;
        }
        
        // 矩阵乘法
        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                for (let k = 0; k < size; k++) {
                    result[i * size + j] += a[i * size + k] * b[k * size + j];
                }
            }
        }
        
        return result;
    }

    // 辅助函数 - 物理模拟
    function runPhysicsSimulation(iterations) {
        // 简化的物理模拟
        const objects = 100;
        const positions = new Array(objects * 3);
        const velocities = new Array(objects * 3);
        
        // 初始化
        for (let i = 0; i < objects * 3; i++) {
            positions[i] = Math.random() * 10;
            velocities[i] = (Math.random() - 0.5) * 0.1;
        }
        
        // 运行模拟
        for (let iter = 0; iter < iterations; iter++) {
            for (let i = 0; i < objects; i++) {
                // 简化的物理更新
                const idx = i * 3;
                positions[idx] += velocities[idx];
                positions[idx + 1] += velocities[idx + 1];
                positions[idx + 2] += velocities[idx + 2];
                
                // 简化的碰撞检测
                if (positions[idx + 1] < 0) {
                    positions[idx + 1] = 0;
                    velocities[idx + 1] = -velocities[idx + 1] * 0.8;
                }
            }
        }
        
        return positions;
    }

    // 计算总分
    function calculateTotalScore(results) {
        return (
            results.singleCore * TEST_CONFIG.weights.singleCore +
            results.multiCore * TEST_CONFIG.weights.multiCore +
            results.memory * TEST_CONFIG.weights.memory +
            results.crypto * TEST_CONFIG.weights.crypto
        );
    }

    // 创建结果HTML
    function createResultHTML(results, totalScore) {
        return `
            <h3>CPU测试结果</h3>
            <p><strong>单核性能得分:</strong> ${formatNumber(results.singleCore)}</p>
            <p><strong>多核性能得分:</strong> ${formatNumber(results.multiCore)}</p>
            <p><strong>内存性能得分:</strong> ${formatNumber(results.memory)}</p>
            <p><strong>加密性能得分:</strong> ${formatNumber(results.crypto)}</p>
            <hr>
            <p><strong>综合性能得分:</strong> ${formatNumber(totalScore)}</p>
            <p>测试完成时间: ${new Date().toLocaleTimeString()}</p>
            <p>核心数: ${navigator.hardwareConcurrency || "未知"}</p>
        `;
    }

    function stopTests() {
        if(!isTesting) return;
        
        // 终止所有Web Workers
        workers.forEach(worker => worker.terminate());
        workers = [];
        isTesting = false;
        
        document.getElementById('cpu-progress').style.width = '0%';
        document.getElementById('result').innerHTML = "测试已中止";
    }

    function showResult(text) {
        document.getElementById('result').innerHTML = text;
    }

    function formatNumber(num) {
        if (num > 1e9) {
            return (num / 1e9).toFixed(2) + " G";
        } else if (num > 1e6) {
            return (num / 1e6).toFixed(2) + " M";
        } else if (num > 1e3) {
            return (num / 1e3).toFixed(2) + " K";
        }
        return Math.round(num).toString();
    }
</script>
</body>
</html>
